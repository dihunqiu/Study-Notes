# 第四章 函数和递归 (C)

## 4.2.6 把函数作为函数的参数 P73

​	C语言中运用到的stdlib.h中有一个叫qsort的库函数，其声明如下：

~~~c
void qsort(void *base, size_t num, size_t size, int ( *comparator ) (const void *, const void *) );
// 参数从左向右依次为 待排序的数组的首地址 元素个数 每个元素的大小 指向函数的指针
// 被指向的函数形式如下
int cmp(const void *, const void *) {...}
~~~

​	指向常数的“万能”的指针：const void * 。

~~~c
//这个指针可以通过强制类型转换变成任意类型的指针
int cmp(const void *a, const void *b) {
	return *(int *)a - *(int *b);
}//可以通过如上 （数据类型）变量名 的方式进行强制类型转换，从而变成任意类型的指针
~~~

## 4.3.4 段错误与栈溢出 P77

​	**编译后产生的内容与操作系统有关**

​	

|  操作系统  | 可执行文件内容的格式 |
| :--------: | :------------------: |
| UNIX/Linux |         ELF          |
|    DOS     |         COFF         |
|  Windows   | PE(由COFF扩充 而来)  |

​	**在可执行文件中段的作用**

|         名称          |            作用            |
| :-------------------: | :------------------------: |
| 正文段(Text Segment)  |        用于存储指令        |
| 数据段(Data Segament) | 用于存储已初始化的全局变量 |
|  BSS段(BSS Segament)  |  用于存储未赋值的全局变量  |

​	**栈空间的大小**

| 操作系统 |                             大小                             |
| :------: | :----------------------------------------------------------: |
|  Linux   | 栈大小是由系统命令ulimit指定的(ulimit -a 显示当前栈大小，ulimit -s 32768将栈大小指定未32MB) |
| Windows  | 栈大小是储存在可执行文件中的。使用gcc可以指定可执行文件栈的大小(例 gcc-Wl,--stack=16777216,栈的大小为16MB) |

## 4.4 竞赛题目选讲

### 1 刽子手游戏

刽子手游戏实质上是一个猜单词的游戏，猜一个单词，每次只能猜一个字母，如果那个字母猜对了，那么在单词中与之所有相同的字母都会显示出来，如果猜错了，那么久少了一个猜单词的机会。

在本题中，小菜鸟们的任务是编写一个“裁判程序”，输入单词和玩家的猜测，并输出结果，分别是玩家赢了(You win.)、玩家输了(You lose.)、

或者玩家中途放弃了(刚开始小编没理解中途放弃是什么操作，其实就是还有猜的机会，但是玩家已经不继续往下输入单词了，就为中途放弃(不知道无小编这样解释得够清楚吗？))

输入输出数据格式：

输入：每组数据包括三行：第一行是游戏编号(当玩家输入-1时程序结束，要记得这个也是作为判断的条件之一哟！)，

第二行为计算机想的单词，第三行为玩家猜的单词(后两行保证只有小写字母)

(样例输入)

1

cheese

chese

2

cheese

abcdefg

3

cheese

abcdefgij

-1

Sample Output

(样例输出)

Round 1

You win.

Round 2

You chickened out.

Round 3

You lose.

~~~c++
#include <stdio.h>
#include <iostream>

using namespace std;

string s1, s2;
int t1, t2, sum;

void guess(char ch) {

	t2 = 0;
	for (int i = 0; i < s1.size(); i++) {
		if (ch == s1[i]) {
			s1[i] = ' ';
			t2 = 1; //如果由正确的字母，t2用于表示正确；
			sum++;
		}
	}
	if (t2 == 0) t1--;

}

int main() {

	int t;
	while (cin >> t && t != -1) {
		cin >> s1 >> s2;
		t1 = 7; //此处t1表示错误的次数
		sum = 0; //sum 用于标识空格的个数
		for (int i = 0; i < s2.size(); i++) {
			guess(s2[i]);
			if ((sum == s1.size() && t1 > 0) || t1 == 0) break;
		}
		if (t1 == 0) cout << "You lose";
		else if (sum == s1.size()) cout << "You win";
		else cout << "You chickened out";
	}
	return 0;

}
~~~

# C++与STL入门(C++)

## 5.1.3 字符串

### getline

#### 一.cin.getline(char* s, streamsize n, char delim)

这个函数所需的头文件是<iostream>。

可以理解为此时getline是cin这个类的一个函数，所在的命名空间是std，因此，输入的时候要写成std::cin.getline()。

这里的参数char* s是输入的字符串变量， n是输入字符串的字符个数（第n个补'\0'）， delim是输入终止条件，即遇到delim所代表的字符就终止输入。

举例：

char str[10];

cin.getline(str, 7, 'a');

当我们输入sdfazsertyg时，str会存放sdf因为我们默认当遇见a时结束。![img](https://img-blog.csdnimg.cn/e9bca2514d2e44f1944ec04e5653592b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCx6KaBIOWuheWcqOWutg==,size_20,color_FFFFFF,t_70,g_se,x_16)

同理，当输入bcdefghijklm时,str会存放bcdefg因为我们规定了只能存放7个字符,而第7位补'\0'。![img](https://img-blog.csdnimg.cn/63eb16d20ee94c7a8d7e068338f1fba5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCx6KaBIOWuheWcqOWutg==,size_20,color_FFFFFF,t_70,g_se,x_16)

#### **二.getline(istream& is, string& str, char delim)**

头文件：<string>

is是标准输入流函数， str是用来存字符的变量名， delim是结束标志，此处作用与cin.getline()里的相同。

需要注意的是：

getline()是string流的函数，只能用于string类型的输入操作。

cin.getline是std流的函数，用于char*类型的输入操作。

换句话说，当你定义了一个string类型变量，只能用getline()来输入。

当你定义了一个char*类型变量，只能用cin/cin.getline()输入。

功能与cin.getline类似：

![img](https://img-blog.csdnimg.cn/cb8d7dfed3044f21882d21676620ca09.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCx6KaBIOWuheWcqOWutg==,size_20,color_FFFFFF,t_70,g_se,x_16)

原文链接：https://blog.csdn.net/weixin_61857742/article/details/124382424

### stringstream

#### 简介



	**stringstream 定义于头文件 <sstream>，它其实是个别名，具体定义如下：

typedef basic_stringstream<char> stringstream;
1
类模板 std::basic_stringstream 实现基于字符串的流上的输入与输出操作。它等效地存储一个 std::basic_string 的实例，并在其上进行输入与输出操作。继承图如下：![img](https://img-blog.csdnimg.cn/b9141a14f06f4ebc97ecb3d18cc9cfc1.png)

#### 构造函数



`stringstream` 的构造函数有很多，这里列举最为常用的两个构造函数：

​	**第一中**

~~~c++
#include <iostream>
#include <sstream>
using namespace std;

int main()
{
    stringstream ss1;
    ss1 << "fre";
    ss1 << "gre";
    cout << ss1.str() << endl;
    
    return 0;
}

/*
输出：
fregre
*/

~~~



**第二种**

~~~c++
#include <iostream>
#include <sstream>
using namespace std;

int main()
{
    string str("asd");
    stringstream ss2(str);
    cout << ss2.str() << endl;

    ss2 << "r";
    cout << ss2.str() << endl;

    ss2 << "13";
    cout << ss2.str() << endl;

    ss2 << "hy";
    cout << ss2.str() << endl;
    
    return 0;
}

/*
输出：
asd
rsd
r13
r13hy
*/

~~~

可以发现，利用第一种构造函数创建对象时，输入字符串后直接进行字符串拼接，**而第二种构造方式，在进行字符串拼接时，首先把原本的字符串覆盖掉，之后再进行拼接。**

如果不想原来的字符串被覆盖，则需要换一种构造方式，如下：

~~~c++
#include <iostream>
#include <sstream>
using namespace std;

int main()
{
    ostringstream ss("1 2 3 4 ", std::ios_base::ate);	// append 方式追加
    cout << ss.str() << endl;

    ss << "5 3 4";
    cout << ss.str() << endl;
    
    return 0;
}
/*
输出：
1 2 3 4 
1 2 3 4 5 3 4
*/

~~~

#### 将整形，浮点型添加到字符串流（实现类型转换）

~~~c++
#include <iostream>
#include <string>
#include <sstream>

using namespace std;

int main() {

	int a;
	float b;
	string s;
	getline(cin, s);
	stringstream ss(s); // 或ss << s 其他类型变量同理 
	ss >> a;			// 将整数添加到字符串流
	cout << a << endl;
	ss.clear();			// 清空ss的内容
	getline(cin, s);
	ss.str(s);
	ss >> b;			// 将浮点型添加到字符串流
	cout << b << endl;
	return 0;

}
~~~



#### 修改，清空stringstream内容

`stringstream` 的内容可以通过 `str()` 函数进行修改、清空：

~~~c++
#include <iostream>
#include <sstream>
using namespace std;

int main()
{
    stringstream ss("fghewoo");
    cout << ss.str() << endl;

    // 修改内容
    ss.str("123456");
    cout << ss.str() << endl;

    // 将内容变为空值
    ss.str("");
    cout << ss.str() << endl;
	
    ss.clear(); // 清空内容
    return 0;
}

/*
输出：
fghewoo
123456

*/

~~~



原文链接：https://blog.csdn.net/weixin_45867382/article/details/122109133**



## 5.1.4 再谈结构体

	### this指针

​	this指针是指向当前对象的指针。this -> 的意思是“当前对象的成员变量x”，即(this*) x。

## 5.1.5 模板

​	模板就是建立通用的模具，大大提高复用性。

### 使函数成为模板

~~~c++
#include <iostream>

using namespace std;

template <typename Y> // 通过此处创建模板 Y

Y sum(Y x, Y y) { // 通过模板，可以使变量为任意类型的变量

	return x + y;

 }

int main() {

	int x1 = 1, y1 = 2;
	double x2 = 2.2, y2 = 4.4;
	cout << sum(x1, y1) << endl;
	cout << sum(x2, y2) << endl;
	return 0;

}
~~~

### 使结构体和类成为模板

~~~c++
#include <iostream>

using namespace std;

// 同过关键字创建模板 T
template <typename T>

// 通过创建的模板 T 使结构体成为模板
struct Point {
	
	//构造函数  通过初始化列表 与 函数默认值 的方式为结构体变量赋值
	Point(T x = 0, T y = 0) : x(x), y(y) {

	}

	T x, y;

};

int main() {

	Point<int> a;
	return 0;

}
~~~

## 5.2 STL初步

### C++标准库头文件之algorithm

algorithm是C++标准库中的头文件，它提供了很多算法和函数模板，可以用于各种数据结构和容器的处理。

**排序算法**：sort：对容器中的元素进行排序，默认按升序排列。
		     stable_sort：类似于sort，但会保持相等元素的相对顺序。
	 	    partial_sort：部分排序，将指定范围内的元素排序，只保证前几个元素有序。
		     nth_element：将第n个元素放置到在排序后的位置。

**查找算法**：find：在容器中查找指定元素，返回第一个匹配的元素的迭代器。
		     binary_search：对已排序的容器进行二分查找，确定某个值是否存在。
		     lower_bound：在有序容器中查找第一个大于或等于指定值的元素。
		     upper_bound：在有序容器中查找第一个大于指定值的元素。

**数值算法**：accumulate：计算序列中元素的累加和或累积乘积。
		     inner_product：计算两个序列的内积。
		     max、min：返回序列中的最大值和最小值。
 		    count：计算容器中等于指定值的元素个数。

**字符串算法**：find、find_first_of、find_if：在字符串中查找指定子串或满足条件的字符。
			 replace：替换字符串中的子串。

**迭代器算法**：copy：将一个序列的元素复制到另一个序列中。
			 transform：将一个序列的元素根据指定的函数转换到另一个序列中。
			 reverse：反转容器中的元素顺序。

### 5.2.1 排序与检索

#### 排序算法sort

~~~c++
//函数声明
void sort( RandomIt first, RandomIt last, Compare comp );
//第一个参数为 起始地址
//第二个参数为 结束地址
//第三个参数为 可选参数，用来指定排序的方法，当没有指定时，默认升序
//sort可以对任意对象进行排序，包括内置类型和自定义类型。前提时重载大于，小于等运算符，或在排序时传入一个比   较函数
//排序对象可以储存于普通数组中，也可以存放在vector中。
~~~

##### 自定义排序方式

~~~c++
#include <iostream>
#include <algorithm>

using namespace std;

bool cmp1(int a, int b) { //定义第一种排序方式

	return a < b;

}

bool cmp2(int a, int b) { //定义第二种排序方式

	return a > b;

}

int main() {

	int num[] = { 10, 10, 56, 78, 91, 102, 1, 2 };
	//不带cmp参数，默认升序
	sort(num, num + sizeof(num) / sizeof(int));
	//输出结果为：1 2 10 10 56 78 91 102
	//传入参数cmp1
	sort(num, num + sizeof(num) / sizeof(int), cmp1);
	//输出结果为：1 2 10 10 56 78 91 102 与默认一致
	//传入参数cmp2
	sort(num, num + sizeof(num) / sizeof(int), cmp2);
	//输出结果为：102 91 78 56 10 10 2 1
	for (int i : num) cout << i << ' ';
	return 0;

}
/*sort()的底层实现方式为快速排序，为两两元素相比较。传入参数cmp后，会在容器内依据参数进行比较，如果返回结果为假，就调换两者位置；如果为真，则保持不变。*/
~~~

##### 对自定义类型进行排序

对结构体进行排序

~~~c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

struct student {

	string name; //学生姓名
	int sum; //总成绩
	int china; //语文
	int math; //数学
	int english; //英语

};

bool cmp(student x, student y) {
	return x.sum > y.sum;
}

int main() {

	student student[10];
	for (int i = 0; i < 5; i++)
	{	
		student[i].math = i + 1;
		student[i].sum = i + 100;
	}
	sort(student, student + 5, cmp);
	for (int i = 0; i < 5; i++) {
		cout << student[i].math << endl;
	}
	return 0;

}
~~~

#### 查找算法lower_bound

底层实现为**二分查找**。

